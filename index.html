<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Happy Birthday Ahmed — Neon Blade God</title>
<meta name="description" content="Epic neon blade Happy Birthday for Ahmed — particles, sound, blade sweep, volumetric light, responsive and accessible." />
<style>
/* =============================
   THEME & RESET
   ============================= */
:root{
  --bg-1: #000000;
  --panel: #030303;
  --neon-a: #00ff88;
  --neon-b: #00ffee;
  --neon-c: #aaff00;
  --glass: rgba(255,255,255,0.02);
  --max-font: clamp(44px, 10vw, 160px);
  --ui-font: 14px;
  --particle-count-default: 180;
  --reduced-motion: no-preference;
}

@media (prefers-reduced-motion: reduce){
  :root{ --reduced-motion: reduce; }
}

/* basic reset */
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%}
body{
  font-family: "Inter", "Orbitron", system-ui, -apple-system, "Segoe UI", Roboto, Arial;
  background: radial-gradient(1000px 400px at 10% 10%, rgba(0,40,20,0.08), transparent 7%),
              linear-gradient(180deg,var(--bg-1), #040506 60%);
  color: #ecffe9;
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
  overflow:hidden;
  display:flex;
  align-items:center;
  justify-content:center;
  min-height:100vh;
}

/* main stage container */
.stage{
  width:100%;
  height:100%;
  position:relative;
  display:grid;
  place-items:center;
  gap:12px;
  padding:4vmin;
  isolation:isolate;
}

/* =============================
   BACKGROUND LAYERS
   ============================= */

/* volumetric fog shafts (decor) */
.volumetric {
  position:absolute;
  inset:0;
  pointer-events:none;
  z-index:0;
  mix-blend-mode:screen;
}
.volumetric .shaft{
  position:absolute;
  width:18%;
  height:140%;
  top:-20%;
  background: linear-gradient(180deg, rgba(0,255,136,0.08), rgba(0,0,0,0));
  filter: blur(40px) saturate(180%);
  transform: skewX(-12deg);
}

/* chromatic bloom overlay to create RGB edges */
.chromatic {
  position:absolute; inset:0; z-index:3; pointer-events:none;
  mix-blend-mode:screen;
}
.chromatic::before, .chromatic::after{
  content:"";
  position:absolute; inset:0;
  background: radial-gradient(900px 300px at 50% 40%, rgba(0,255,136,0.07), transparent 15%);
  filter: blur(28px) saturate(180%);
  transform: translateX(0);
}
.chromatic::before{ transform: translateX(-6px) scale(1.02); opacity:0.85; }
.chromatic::after{ transform: translateX(6px) scale(1.02); opacity:0.6; }

/* grain for retro texture */
.grain {
  position:absolute; inset:0; z-index:60; pointer-events:none;
  background-image: radial-gradient(rgba(255,255,255,0.02) 0.6px, transparent 0.6px);
  background-size:3px 3px;
  opacity:0.45;
  mix-blend-mode:overlay;
}

/* subtle vignette */
.vignette{
  position:absolute; inset:0; z-index:50; pointer-events:none;
  background: radial-gradient(70% 50% at 50% 40%, rgba(0,0,0,0) 30%, rgba(0,0,0,0.6) 85%);
}

/* =============================
   HERO: SVG TYPE with MASKS & GLOW
   ============================= */

.hero {
  position:relative;
  z-index:10;
  display:flex;
  align-items:center;
  justify-content:center;
  width:min(1200px, 96vw);
  margin:auto;
}

.svg-wrap{
  width:100%;
  max-width:1200px;
  display:block;
}

/* underline for royalty */
.underline{
  width:60%;
  height:4px;
  border-radius:999px;
  margin:14px auto 0;
  background: linear-gradient(90deg, rgba(0,255,136,0.22), rgba(0,255,255,0.18), rgba(170,255,0,0.16));
  filter: blur(6px) saturate(160%);
  box-shadow: 0 0 28px rgba(0,255,136,0.06);
}

/* fallback heading for no-js */
.fallback {
  display:none;
  font-weight:900;
  font-size:var(--max-font);
  color:var(--neon-a);
  text-shadow: 0 8px 30px rgba(0,255,136,0.08);
  text-align:center;
}

/* =============================
   BLADE SWEEP & GLINTS
   ============================= */

.blade {
  position:absolute;
  top:0;
  left:-60%;
  width:36%;
  height:120%;
  transform:skewX(-20deg);
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), rgba(0,255,136,0.16), transparent);
  filter: blur(20px) saturate(160%);
  mix-blend-mode:screen;
  z-index:6;
  will-change:left, transform, opacity;
  animation:blade 3s linear infinite;
  opacity:0;
}

.blade.small{
  width:18%;
  height:130%;
  top:-10%;
  animation-duration:2.2s;
  filter: blur(8px) saturate(200%);
  opacity:0.9;
}
.blade.fine{
  width:8%;
  height:110%;
  top:2%;
  animation-duration:4s;
  filter: blur(4px) saturate(260%);
  opacity:0.6;
}

@keyframes blade {
  0%{ left:-80%; opacity:0; transform: skewX(-18deg) translateY(0); }
  10%{ opacity:0.9; }
  50%{ left:120%; transform: skewX(-22deg) translateY(-4%); opacity:1; }
  100%{ left:160%; opacity:0; transform: skewX(-14deg) translateY(2%); }
}

/* =============================
   UI CONTROLS (BUTTONS) — minimal & accessible
   ============================= */

.controls {
  position: absolute;
  bottom: min(6vh, 34px);
  left: 50%;
  transform: translateX(-50%);
  display:flex;
  gap:12px;
  z-index:40;
  align-items:center;
  justify-content:center;
  pointer-events: auto;
}

.btn {
  -webkit-tap-highlight-color: transparent;
  background: linear-gradient(90deg, rgba(0,255,136,0.12), rgba(0,255,255,0.08));
  border: 1px solid rgba(255,255,255,0.04);
  padding: 10px 18px;
  border-radius: 12px;
  font-weight:700;
  font-size:var(--ui-font);
  color: #d9ffef;
  cursor:pointer;
  backdrop-filter: blur(4px) saturate(120%);
  box-shadow: 0 8px 30px rgba(0,0,0,0.6);
  transition: transform .14s ease, box-shadow .14s ease, opacity .14s ease;
  display:inline-flex;
  gap:8px;
  align-items:center;
}
.btn:active{ transform: translateY(2px) }
.btn:focus{ outline: 3px solid rgba(0,255,136,0.12); outline-offset:4px; }

/* special green primary button */
.btn.primary{
  background: linear-gradient(90deg, #00ff88, #00ffee, #aaff00);
  color:#001210;
  font-weight:800;
  box-shadow: 0 12px 36px rgba(0,255,136,0.14);
  transform: translateZ(0);
}

/* small label next to controls */
.label {
  font-size:12px; color: rgba(220,255,230,0.7);
  display:inline-block; padding:6px 10px; border-radius:8px; background: rgba(0,0,0,0.25);
}

/* toggle switch */
.switch {
  width:48px; height:28px; background: rgba(255,255,255,0.06); border-radius:999px; padding:4px; display:inline-block; position:relative; cursor:pointer;
}
.switch .knob{
  width:18px;height:18px;border-radius:50%; background:linear-gradient(180deg,#fff,#dff); position:absolute; left:4px; top:4px; transition:left .18s ease, background .18s ease;
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
}

/* toggle active */
.switch.on{ background: linear-gradient(90deg,#002b14,#00331a); }
.switch.on .knob{ left:26px; background: linear-gradient(90deg,#00ff88,#00ffee); }

/* responsive stacking on tiny screens */
@media (max-width:520px){
  .controls{ gap:8px; padding:0 6px; bottom:6vh; }
  .btn{ padding:9px 12px; font-size:13px; border-radius:10px; }
  .underline{ width:80%; }
}

/* =============================
   PARTICLE CANVAS (top-level)
   ============================= */
#fxCanvas{
  position:fixed; inset:0; z-index:5; pointer-events:none;
  display:block;
}

/* =============================
   ACCESSIBLE HIDDEN TEXT
   ============================= */
.visually-hidden{
  position:absolute!important; height:1px; width:1px; overflow:hidden; clip:rect(1px,1px,1px,1px);
  white-space:nowrap; border:0; padding:0; margin:-1px;
}

/* END CSS */
</style>

<!-- Load a nice techno/cyber font -->
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&display=swap" rel="stylesheet">

</head>
<body>
  <main class="stage" role="main" aria-labelledby="hb-title">

    <!-- Volumetric shafts (decorative) -->
    <div class="volumetric" aria-hidden="true">
      <div class="shaft" style="left:8%; transform:skewX(-12deg) scaleX(1.1);"></div>
      <div class="shaft" style="left:40%; background: linear-gradient(180deg, rgba(0,255,200,0.06), rgba(0,0,0,0)); transform:skewX(-6deg) scaleX(1.3);"></div>
      <div class="shaft" style="left:72%; background: linear-gradient(180deg, rgba(170,255,0,0.04), rgba(0,0,0,0)); transform:skewX(-12deg) scaleX(0.9);"></div>
    </div>

    <!-- Chromatic overlay + grain + vignette -->
    <div class="chromatic" aria-hidden="true"></div>
    <div class="vignette" aria-hidden="true"></div>
    <div class="grain" aria-hidden="true"></div>

    <!-- moving blade sweeps -->
    <div class="blade" aria-hidden="true"></div>
    <div class="blade small" aria-hidden="true"></div>
    <div class="blade fine" aria-hidden="true"></div>

    <!-- main hero (SVG neon text) -->
    <div class="hero" role="region" aria-label="Happy Birthday Ahmed display">
      <h1 id="hb-title" class="visually-hidden">Happy Birthday Ahmed</h1>

      <div class="svg-wrap" role="img" aria-label="Happy Birthday Ahmed neon">
        <svg viewBox="0 0 1400 320" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" id="neonSVG">
          <defs>
            <!-- animated green-rainbow gradient -->
            <linearGradient id="g1" x1="0%" x2="100%" y1="0%" y2="0%">
              <stop offset="0%" stop-color="#00ff88" />
              <stop offset="20%" stop-color="#00ffee" />
              <stop offset="45%" stop-color="#aaff00" />
              <stop offset="70%" stop-color="#7cf7a6" />
              <stop offset="100%" stop-color="#00ff88" />
              <animate attributeName="x1" values="0%;100%;0%" dur="9s" repeatCount="indefinite" />
              <animate attributeName="x2" values="100%;200%;100%" dur="9s" repeatCount="indefinite" />
            </linearGradient>

            <!-- glow filters -->
            <filter id="glow1" x="-50%" y="-50%" width="200%" height="200%">
              <feGaussianBlur stdDeviation="8" result="b"/>
              <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
            </filter>

            <filter id="glow2" x="-60%" y="-60%" width="220%" height="220%">
              <feGaussianBlur stdDeviation="18" result="b2"/>
              <feMerge><feMergeNode in="b2"/><feMergeNode in="SourceGraphic"/></feMerge>
            </filter>

            <!-- mask for text -->
            <mask id="maskText">
              <rect width="100%" height="100%" fill="black"/>
              <text id="theText" x="50%" y="60%" text-anchor="middle"
                    font-family="Orbitron, Arial" font-weight="900" font-size="120" fill="white" letter-spacing="1.5">
                Happy Birthday Ahmed
              </text>
            </mask>

          </defs>

          <!-- carved deep shadow -->
          <text x="50%" y="60%" text-anchor="middle" font-family="Orbitron, Arial" font-weight="900" font-size="120"
                fill="none" stroke="rgba(0,0,0,0.9)" stroke-width="20" paint-order="stroke fill">
            Happy Birthday Ahmed
          </text>

          <!-- gradient fill through mask -->
          <rect width="100%" height="100%" fill="url(#g1)" mask="url(#maskText)" filter="url(#glow2)"></rect>

          <!-- bright core -->
          <text x="50%" y="60%" text-anchor="middle" font-family="Orbitron, Arial" font-weight="900" font-size="120"
                fill="url(#g1)" style="filter:url(#glow1);">
            Happy Birthday Ahmed
          </text>

          <!-- animated micro highlights stroke -->
          <text x="50%" y="60%" text-anchor="middle" font-family="Orbitron, Arial" font-weight="900" font-size="120"
                fill="none" stroke="rgba(255,255,255,0.12)" stroke-width="2" style="mix-blend-mode:screen;">
            <animate attributeName="stroke-opacity" values="0.02;0.3;0.02" dur="6s" repeatCount="indefinite" />
            Happy Birthday Ahmed
          </text>

        </svg>
      </div>

      <div class="underline" aria-hidden="true"></div>
    </div>

    <!-- canvas used for high-performance particles and effects -->
    <canvas id="fxCanvas" aria-hidden="true"></canvas>

    <!-- controls: particles button, toggle continuous, sound toggle -->
    <div class="controls" role="region" aria-label="Controls">
      <button class="btn primary" id="burstBtn" aria-pressed="false" title="Burst particles">✨ Particles</button>

      <div style="display:flex; align-items:center; gap:8px;">
        <span class="label">Rain</span>
        <div class="switch" id="rainSwitch" role="switch" aria-checked="false" tabindex="0">
          <div class="knob"></div>
        </div>
      </div>

      <div style="display:flex; align-items:center; gap:8px;">
        <span class="label">Sound</span>
        <div class="switch" id="soundSwitch" role="switch" aria-checked="false" tabindex="0">
          <div class="knob"></div>
        </div>
      </div>
    </div>

    <!-- accessible fallback if scripts disabled -->
    <div class="fallback" aria-hidden="true">Happy Birthday Ahmed</div>

  </main>

<script>
/* ============================================================
   Advanced JS: particle engine, continuous rain, pointer trails,
   WebAudio ambient + click jingle, responsive/respect reduced-motion
   ============================================================ */

(function () {
  // preferences
  const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  if (prefersReduced) {
    // If reduced motion is preferred, simplify: hide animated blades and do not run heavy particles automatically.
    document.querySelectorAll('.blade').forEach(b => b.style.display = 'none');
  }

  // Canvas setup
  const canvas = document.getElementById('fxCanvas');
  const ctx = canvas.getContext('2d', { alpha: true });
  let DPR = Math.max(1, window.devicePixelRatio || 1);

  function resize() {
    DPR = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor(window.innerHeight * DPR);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Particle system (object pool)
  const pool = [];
  const active = [];
  let maxPool = 900; // safety cap
  let ambientInterval = null;
  let rainActive = false;

  // utility
  const rand = (a,b) => Math.random()*(b-a)+a;
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));

  // Particle class (circle or blade spark)
  class P {
    constructor(){
      this.reset();
    }
    reset() {
      this.x = 0; this.y = 0;
      this.vx = 0; this.vy = 0;
      this.size = 3;
      this.life = 1;
      this.age = 0;
      this.h = 140; // hue base (green)
      this.alpha = 1;
      this.type = 'dot'; // or 'spark'
      this.glow = 10;
      this.rotation = 0;
      this.spin = 0;
    }
    initBurst(cx, cy, power=1) {
      this.x = cx + rand(-30,30);
      this.y = cy + rand(-20,20);
      const angle = rand(0, Math.PI*2);
      const speed = rand(40, 240) * power;
      this.vx = Math.cos(angle) * speed;
      this.vy = Math.sin(angle) * speed * 0.6 - rand(20,120) * (power*0.5);
      this.size = rand(2, 10);
      this.life = rand(1.0, 2.6);
      this.age = 0;
      this.h = rand(120, 180); // green hues range (120-180)
      this.alpha = 1;
      this.type = Math.random() < 0.7 ? 'dot' : 'spark';
      this.glow = rand(8, 28);
      this.rotation = rand(0, Math.PI*2);
      this.spin = rand(-4, 4);
    }
    initAmbient(bottomX) {
      this.x = bottomX;
      this.y = canvas.height / DPR + rand(0, 40);
      this.vx = rand(-8, 8);
      this.vy = rand(-60, -30);
      this.size = rand(1.2, 4.2);
      this.life = rand(6, 12);
      this.age = 0;
      this.h = rand(125, 170);
      this.alpha = 0.85;
      this.type = 'dot';
      this.glow = rand(6, 18);
      this.spin = rand(-1, 1);
    }
    step(dt) {
      this.age += dt;
      if (this.age >= this.life) return false;
      // integrate
      this.vy += 240 * dt; // gravity px/s^2
      this.vx *= (1 - 0.02*dt*60);
      this.vy *= (1 - 0.002*dt*60);
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.rotation += this.spin * dt;
      // floor bounce
      const floorY = (canvas.height / DPR) - this.size - 8;
      if (this.y > floorY) {
        this.y = floorY;
        this.vy *= -0.35;
        this.vx *= 0.7;
      }
      // fade in/out
      const lifeRatio = this.age / this.life;
      this.alpha = 1 - lifeRatio;
      return true;
    }
    draw(ctx) {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = clamp(this.alpha, 0, 1);
      const color = `hsl(${this.h}deg 90% ${50}%)`;
      if (this.type === 'dot') {
        ctx.beginPath();
        ctx.shadowBlur = this.glow;
        ctx.shadowColor = color;
        ctx.fillStyle = color;
        ctx.arc(this.x, this.y, Math.max(0.6, this.size), 0, Math.PI*2);
        ctx.fill();
      } else {
        // spark: rotated rectangle
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.shadowBlur = this.glow;
        ctx.shadowColor = color;
        ctx.fillStyle = color;
        ctx.fillRect(-this.size*1.2, -this.size/3, this.size*2.4, this.size*0.66);
      }
      ctx.restore();
    }
  }

  // pool factory
  function poolCreate(n) {
    for (let i=0;i<n;i++){
      pool.push(new P());
    }
  }
  poolCreate(300);

  function acquire() {
    if (pool.length > 0) return pool.pop();
    if ((active.length + pool.length) < maxPool) {
      return new P();
    }
    return null;
  }
  function release(p) {
    p.reset();
    pool.push(p);
  }

  // main loop
  let last = performance.now();
  let running = true;
  function frame(now) {
    if (!running) return;
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    ctx.clearRect(0,0,canvas.width, canvas.height);

    // ambient glow layer (big blurred ellipse)
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    const grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 120, canvas.width/2, canvas.height/2, canvas.width/1.2);
    grad.addColorStop(0, 'rgba(0,255,136,0.06)');
    grad.addColorStop(0.6, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,canvas.width, canvas.height);
    ctx.restore();

    // update and draw active particles
    for (let i = active.length - 1; i >= 0; i--) {
      const p = active[i];
      const alive = p.step(dt);
      if (!alive) {
        const rem = active.splice(i,1)[0];
        release(rem);
      } else {
        p.draw(ctx);
      }
    }

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);

  // spawn burst at center
  function burst(count=160, power=1.0) {
    const rect = document.querySelector('.hero').getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    for (let i=0;i<count;i++){
      const p = acquire();
      if (!p) break;
      p.initBurst(cx, cy, power);
      active.push(p);
    }
  }

  // ambient rain spawn (continuous)
  function spawnAmbientOnce() {
    const x = rand(40, window.innerWidth - 40);
    const p = acquire();
    if (!p) return;
    p.initAmbient(x);
    active.push(p);
  }

  // handle continuous rain toggle
  const rainSwitch = document.getElementById('rainSwitch');
  function setRain(enabled) {
    rainActive = !!enabled;
    rainSwitch.classList.toggle('on', rainActive);
    rainSwitch.setAttribute('aria-checked', rainActive ? 'true' : 'false');
    if (rainActive) {
      // spawn interval
      ambientInterval = setInterval(() => {
        // spawn variable number for natural look
        const n = Math.random() < 0.5 ? 1 : Math.floor(rand(1,3));
        for (let i=0;i<n;i++) spawnAmbientOnce();
      }, 220);
    } else {
      clearInterval(ambientInterval);
      ambientInterval = null;
    }
  }
  // click/tap handler on switch element
  rainSwitch.addEventListener('click', () => setRain(!rainActive));
  rainSwitch.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); setRain(!rainActive); }
  });

  // burst button
  const burstBtn = document.getElementById('burstBtn');
  burstBtn.addEventListener('click', () => {
    // small camera-shake effect on burst
    animateScreenShake(8, 350);
    burst(Math.floor(rand(120, 260)), 1.2);
    // play jingle click
    if (audioEngine && audioEngine.enabled) {
      audioEngine.playClick();
    }
  });

  // pointer trail: spawn small particles following pointer while pressing
  let isDown = false;
  let pointerX = window.innerWidth/2, pointerY = window.innerHeight/2;
  window.addEventListener('pointerdown', (e) => { isDown = true; pointerX = e.clientX; pointerY = e.clientY; spawnTrail(pointerX, pointerY, 12); });
  window.addEventListener('pointerup', () => { isDown = false; });
  window.addEventListener('pointermove', (e) => { pointerX = e.clientX; pointerY = e.clientY; if (isDown) spawnTrail(pointerX, pointerY, 4); });

  function spawnTrail(x,y,count=6) {
    for (let i=0;i<count;i++){
      const p = acquire();
      if (!p) break;
      p.x = x + rand(-12,12);
      p.y = y + rand(-12,12);
      p.vx = rand(-40,40);
      p.vy = rand(-80,-16);
      p.size = rand(1.4,4.6);
      p.life = rand(0.6,1.6);
      p.age = 0;
      p.h = rand(120, 180);
      p.alpha = 1;
      p.glow = rand(6,18);
      active.push(p);
    }
  }

  // affect blade positions via pointer for parallax
  const blades = document.querySelectorAll('.blade');
  window.addEventListener('pointermove', (e) => {
    const nx = (e.clientX / window.innerWidth) - 0.5;
    const ny = (e.clientY / window.innerHeight) - 0.5;
    blades.forEach((b, i) => {
      const depth = (i+1) * 0.9;
      b.style.transform = `translateX(${nx * 40 * depth}px) translateY(${ny * 8 * depth}px) skewX(-20deg)`;
    });
  });

  // small screen tap: burst on double-tap (friendly)
  let lastTap = 0;
  window.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTap < 350) {
      burst(120, 1.0); // double-tap burst
    }
    lastTap = now;
  });

  // camera shake (subtle)
  let shakeTimer = null;
  function animateScreenShake(magnitude=6, duration=300) {
    const root = document.documentElement;
    const start = performance.now();
    if (shakeTimer) cancelAnimationFrame(shakeTimer);
    function step(now) {
      const t = (now - start) / duration;
      if (t >= 1) {
        root.style.transform = '';
        return;
      }
      const damper = 1 - t;
      const x = (rand(-1,1) * magnitude * damper).toFixed(2);
      const y = (rand(-1,1) * magnitude * damper).toFixed(2);
      root.style.transform = `translate(${x}px, ${y}px)`;
      shakeTimer = requestAnimationFrame(step);
    }
    shakeTimer = requestAnimationFrame(step);
  }

  // =========================
  // WebAudio: ambient drone + click jingle
  // =========================
  let audioEngine = null;
  const soundSwitch = document.getElementById('soundSwitch');
  function setSoundOn(on) {
    soundSwitch.classList.toggle('on', !!on);
    soundSwitch.setAttribute('aria-checked', !!on ? 'true' : 'false');
    if (on) {
      if (!audioEngine) {
        audioEngine = createAudioEngine();
        audioEngine.start();
      } else {
        audioEngine.enable();
      }
    } else {
      if (audioEngine) audioEngine.disable();
    }
  }
  soundSwitch.addEventListener('click', () => {
    const isOn = soundSwitch.classList.contains('on');
    setSoundOn(!isOn);
  });
  soundSwitch.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); setSoundOn(!soundSwitch.classList.contains('on')); }
  });

  // Create a small WebAudio engine that produces ambient pad and a light click
  function createAudioEngine() {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!AudioContext) return null;
    const ctx = new AudioContext();
    const master = ctx.createGain(); master.gain.value = 0.12; master.connect(ctx.destination);
    const engine = {
      ctx, master, enabled: true,
      start() {
        // create a soft layered pad using detuned oscillators + subtle LFO
        // pad: two oscillators with lowpass and reverb-like delay
        const o1 = ctx.createOscillator();
        o1.type = 'sine'; o1.frequency.value = 110; // A2 base
        const o2 = ctx.createOscillator();
        o2.type = 'sine'; o2.frequency.value = 110 * 1.005; // slight detune

        // amplitude envelope
        const g = ctx.createGain(); g.gain.value = 0.0;
        o1.connect(g); o2.connect(g);

        // lowpass for mellow tone
        const lp = ctx.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 800;
        g.connect(lp);

        // delay for spaciousness
        const d = ctx.createDelay(); d.delayTime.value = 0.8;
        const fb = ctx.createGain(); fb.gain.value = 0.22;
        lp.connect(d); d.connect(fb); fb.connect(d);

        // connect both to master
        lp.connect(master);
        d.connect(master);

        // LFO to modulate filter cutoff
        const lfo = ctx.createOscillator(); lfo.type = 'sine'; lfo.frequency.value = 0.06;
        const lfoGain = ctx.createGain(); lfoGain.gain.value = 200;
        lfo.connect(lfoGain);
        lfoGain.connect(lp.frequency);

        // start
        o1.start(); o2.start(); lfo.start();

        // slow fade in
        const now = ctx.currentTime;
        g.gain.cancelScheduledValues(now);
        g.gain.setValueAtTime(0, now);
        g.gain.linearRampToValueAtTime(0.9, now + 3.0);

        engine.pad = { o1, o2, g, lfo, lp, d, fb };
      },
      enable() {
        if (ctx.state === 'suspended') ctx.resume();
        this.enabled = true;
        master.gain.value = 0.12;
      },
      disable() {
        // smooth fade
        master.gain.linearRampToValueAtTime(0.0001, ctx.currentTime + 0.6);
        this.enabled = false;
      },
      playClick() {
        if (!this.enabled) return;
        const s = ctx.createOscillator();
        s.type = 'triangle';
        s.frequency.value = 880;
        const g2 = ctx.createGain();
        g2.gain.value = 0;
        s.connect(g2); g2.connect(master);
        const now = ctx.currentTime;
        g2.gain.setValueAtTime(0.0, now);
        g2.gain.linearRampToValueAtTime(0.18, now + 0.002);
        g2.gain.exponentialRampToValueAtTime(0.0001, now + 0.22);
        s.frequency.setValueAtTime(880, now);
        s.frequency.exponentialRampToValueAtTime(660, now + 0.22);
        s.start(now);
        s.stop(now + 0.26);
      }
    };
    return engine;
  }

  // For user-gesture audio permission on some browsers, start audio when user toggles sound or interacts
  // We will attach a minimal start on first click to unlock audio context
  let audioUnlocked = false;
  const unlockAudioIfNeeded = async () => {
    if (audioUnlocked) return;
    audioUnlocked = true;
    if (!audioEngine) {
      audioEngine = createAudioEngine();
      if (audioEngine) audioEngine.start();
    } else {
      audioEngine.enable();
    }
  };

  // On first user gesture, optionally start audio if toggled on
  window.addEventListener('pointerdown', () => { if (soundSwitch.classList.contains('on')) unlockAudioIfNeeded(); }, { once: false });

  // Set initial world state
  setRain(false);
  setSoundOn(false);

  // Expose small API for console
  window._neon = {
    burst, setRain, spawnTrail, setSoundOn, activeParticles: active.length
  };

})(); // end IIFE
</script>

</body>
       </html>
